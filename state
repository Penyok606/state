Призначення
Дозволяє об'єктові варіювати свою поведінку залежно від внутрішнього стану.

Застосовність
Слід використовувати шаблон Стан у випадках, коли:

поведінка об'єкта залежить від його стану та повинна змінюватись під час виконання програми;
у коді операцій зустрічаються складні умовні оператори, у котрих вибір гілки залежить від стану. Зазвичай у такому разі стан представлено константами, що перелічуються. 
До того ж часто одна й та ж структура умовного оператору повторюється у декількох операціях. Шаблон Стан пропонує замінити кожну гілку окремим класом. Це дозволить трактувати 
стан об'єкта як самостійний об'єкт, котрий може змінитися незалежно від інших.

Переваги та недоліки
Переваги
переваги застосування поліморфної поведінки очевидні, а також легше додавати стан для підтримки додаткової поведінки.
поведінка об'єкта є результатом функції свого стану, і поведінка змінюється під час виконання в залежності від стану.
покращує згуртованість, оскільки специфічні для стану особливості поведінки об'єднуються в класи ConcreteState, які розміщуються в одному місці в коді.
Недоліки
Зростає кількість класів

#include <iostream>
#include <string>

using namespace std;

class Creature
{
private:
	struct State
	{
		virtual string response() = 0;
	};
	struct Frog : public State
	{
		string response() { return " Ribbet!"; }
	};
	struct Prince : public State
	{
		string response() { return " Darling!"; }
	};
	State* state;
public:
	Creature() : state(new Frog()) {}
	void greet()
	{
		cout << state->response() << endl;
	}
	void kiss()
	{
		delete state;
		state = new Prince;
	}
};
void main()
{
	Creature creature;
	creature.greet();
	creature.kiss();
	creature.greet();
}
